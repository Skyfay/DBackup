import { NextRequest, NextResponse } from "next/server";
import { registerAdapters } from "@/lib/adapters";
import { storageService } from "@/services/storage-service";
import { consumeDownloadToken, markTokenUsed } from "@/lib/download-tokens";
import path from "path";
import os from "os";
import fs from "fs";
import { logger } from "@/lib/logger";
import { wrapError } from "@/lib/errors";

const log = logger.child({ route: "storage/public-download" });
registerAdapters();

/**
 * Public download endpoint using temporary tokens
 *
 * This endpoint does NOT require authentication.
 * Instead, it validates a temporary, single-use token that was
 * generated by an authenticated user via the download-url endpoint.
 *
 * Tokens expire after 5 minutes and can only be used once.
 */
export async function GET(req: NextRequest) {
    let tempFile: string | null = null;

    try {
        const { searchParams } = new URL(req.url);
        const token = searchParams.get("token");

        log.debug("Public download request received", { tokenPrefix: token?.substring(0, 16) });

        if (!token) {
            log.debug("Missing token in request");
            return NextResponse.json({ error: "Missing token" }, { status: 400 });
        }

        // Validate the token (does NOT mark as used yet)
        const tokenData = consumeDownloadToken(token);

        if (!tokenData) {
            log.debug("Token invalid or expired");
            return NextResponse.json({
                error: "Invalid or expired token. Please generate a new download link."
            }, { status: 401 });
        }

        log.debug("Token validated", { storageId: tokenData.storageId, file: tokenData.file, decrypt: tokenData.decrypt });

        const { storageId, file, decrypt } = tokenData;

        const tempDir = os.tmpdir();
        const tempName = `${path.basename(file)}_${Date.now()}`;
        tempFile = path.join(tempDir, tempName);

        // Download the file
        const result = await storageService.downloadFile(storageId, file, tempFile, decrypt);

        if (!result.success) {
            if (fs.existsSync(tempFile)) fs.unlinkSync(tempFile);
            return NextResponse.json({ error: "Download failed" }, { status: 500 });
        }

        // Read file into buffer
        const fileBuffer = fs.readFileSync(tempFile);

        // Cleanup temp file
        fs.unlinkSync(tempFile);

        // Mark token as used ONLY after successful download
        markTokenUsed(token);
        log.debug("Download successful, token marked as used", { fileSize: fileBuffer.length });

        // Determine filename
        let downloadFilename = path.basename(file);

        if (result.isZip) {
            downloadFilename = downloadFilename.replace(/\.enc$/, "") + ".zip";
            if (!downloadFilename.endsWith(".zip")) downloadFilename += ".zip";
        } else if (decrypt && downloadFilename.endsWith(".enc")) {
            downloadFilename = downloadFilename.slice(0, -4);
        }

        return new NextResponse(fileBuffer, {
            headers: {
                "Content-Disposition": `attachment; filename="${downloadFilename}"`,
                "Content-Type": result.isZip ? "application/zip" : "application/octet-stream",
            }
        });

    } catch (error: unknown) {
        if (tempFile && fs.existsSync(tempFile)) {
            try { fs.unlinkSync(tempFile); } catch { /* ignore */ }
        }

        log.error("Public download error", {}, wrapError(error));
        return NextResponse.json({ error: "Download failed" }, { status: 500 });
    }
}
